/*******************************************************************************
 * Geometry Tools
 *   - flipCoin: 50% chance of returning true
 *   - normalize: Helper with math for movement components
 *   - distance: returns distance between p1 and p2
 *   - Point:
 *       copy
 *       distance
 *       isNear
 *       LineOfSight
 *   - Line:
 *       print
 *       copy
 */
define(['./constants'], function(Constants){
    function _flipCoin(){
        return Math.random()>0.5;
    }
    function _normalize(x, y){
        return y == 0 ? 1 : Math.abs(Math.sqrt(1/(Math.pow(x/y,2)+1))/y);
    }
    function _distance(x1, y1, x2, y2){
        return Math.sqrt(Math.pow(x1-x2,2)+Math.pow(y1-y2,2));
    }
    function _intersects(p1, q1, p2, q2){
        function orientation(p, q, r){
            var o = (q.y-p.y)*(r.x-q.x) - (q.x-p.x)*(r.y-q.y);
            if(o == 0) return 0;
            return (o>0) ? 1 : 2;
        }
        function onSegment(p, q, r){
            return q.x <= Math.max(p.x, r.x) && q.x > Math.min(p.x, r.x) &&
                q.y <= Math.max(p.y, r.y) && q.y > Math.min(p.y, r.y);
        }
        var o1 = orientation(p1,q1,p2);
        var o2 = orientation(p1,q1,q2);
        var o3 = orientation(p2,q2,p1);
        var o4 = orientation(p2,q2,q1);

        return (o1 != o2 && o3 != o4) ||
            (o1 == 0 && onSegment(p1, p2, q1)) ||
            (o2 == 0 && onSegment(p1, q2, q1)) ||
            (o3 == 0 && onSegment(p2, p1, q2)) ||
            (o4 == 0 && onSegment(p2, q1, q2));
    }
    function Point(x, y){
        this.x = x;
        this.y = y;
        this.copy = function(){
            return new Point(this.x, this.y);
        };
        this.distance = function(other){
            return _distance(this.x, this.y, other.x, other.y);
        };
        this.isNear = function(other, rad){
            if(rad)
                return _distance(this.x, this.y, other.x, other.y) < rad;
            else
                return _distance(this.x, this.y, other.x, other.y) < Constants.nearVal;
        };
        this.lineOfSight = function(other, walls){
            return !walls.some(function(w){
                return _intersects(this, other, w.p, w.q);
            });
        };
    }
    function Line(p, q){
        this.p = p;
        this.q = q;
        this.print = function(){
            console.log('p : ( '+this.p.x+', '+this.p.y+' )');
            console.log('q : ( '+this.q.x+', '+this.q.y+' )');
        }
        this.copy = function(){
            return new Line(this.p.copy(), this.q.copy());
        };
    }
    return {
        flipCoin: _flipCoin,
        normalize: _normalize,
        distance: _distance,
        Point: Point,
        Line: Line
    };
});
